---
title: Qt on Mac摸索记录 - 其三
abbrlink: 24435
date: 2019-09-19 13:01:46
tags:
  - 教程
  - Qt
  - C++
categories:
  - 教程
footnote: true
---

前面两篇我们还是在研究比较基础的模块，还没有涉及具体的GUI部分。从这篇开始我们来研究GUI开发。

## First program, more

在第一篇文章里面我们写了一个简单的窗口程序：

```cpp
#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[]) {

    QApplication app(argc, argv);

    QWidget window;

    window.resize(250, 150);
    window.setWindowTitle("Simple example");
    window.show();

    return app.exec();
}
```

这里我们将其扩展一下。

### 鼠标图标的例子

这个例子将展示控件的组合方式

```cpp
// cursors
#include <QApplication>
#include <QWidget>
#include <QFrame>
#include <QGridLayout>

class Cursors : public QWidget
{
public:
  Cursors(QWidget *parent = 0);
};

Cursors::Cursors (QWidget *parent)
  : QWidget (parent)
{
  QFrame* frame1 = new QFrame(this);
  frame1->setFrameStyle(QFrame::Box);
  frame1->setCursor(Qt::SizeAllCursor);

  QFrame *frame2 = new QFrame(this);
  frame2->setFrameStyle(QFrame::Box);
  frame2->setCursor(Qt::WaitCursor) ;

  QFrame *frame3 = new QFrame(this);
  frame3->setFrameStyle(QFrame::Box);
  frame3->setCursor(Qt::PointingHandCursor);

  QGridLayout *grid = new QGridLayout(this);
  grid->addWidget(frame1, 0, 0);
  grid->addWidget(frame2, 0, 1);
  grid->addWidget(frame3, 0, 2);

  setLayout(grid);
}

int main(int argc, char*argv[]) {
  QApplication app(argc, argv);

  Cursors window;
  window.resize(350, 150);
  window.setWindowTitle("Cursors");
  window.show();

  return app.exec();
}
```

运行界面如下：

<img src="https://imgs.codewoody.com/uploads/big/1a14bb5978e2f4d7844b005ed289dbf6.png" style="width: 70%; border: none">

将鼠标放到不同的框里面，鼠标的图标形态会发生变化。

### 按钮与数据交互

我们来写一个累加累减小工具。这次我们需要写三个文件：

```cpp
// plusminus.h
#pragma once

#include <QWidget>
#include <QApplication>
#include <QPushButton>
#include <QLabel>

class PlusMinus : public QWidget {

  Q_OBJECT

  public:
    PlusMinus(QWidget *parent = 0);

  private slots:
    void OnPlus();
    void OnMinus();

  private:
    QLabel *lbl;
};
```

```cpp
// plusminus.cpp
#include "plusminus.h"
#include <QGridLayout>

PlusMinus::PlusMinus(QWidget *parent)
    : QWidget(parent) {
  QPushButton *plsBtn = new QPushButton("+", this);
  QPushButton *minBtn = new QPushButton("-", this);
  lbl = new QLabel("0", this);
  
  QGridLayout *grid = new QGridLayout(this);
  grid->addWidget(plsBtn, 0, 0);
  grid->addWidget(minBtn, 0, 1);
  grid->addWidget(lbl, 1, 1);

  setLayout(grid);  

  connect(plsBtn, &QPushButton::clicked, this, &PlusMinus::OnPlus);
  connect(minBtn, &QPushButton::clicked, this, &PlusMinus::OnMinus);
}

void PlusMinus::OnPlus() {
  int val = lbl->text().toInt();
  val++;
  lbl->setText(QString::number(val));
}

void PlusMinus::OnMinus() {
  int val = lbl->text().toInt();
  val--;
  lbl->setText(QString::number(val));
}
```

```cpp
// main.cpp
#include "plusminus.h"


int main(int argc, char *argv[]) {
    
  QApplication app(argc, argv);  
    
  PlusMinus window;

  window.resize(300, 190);
  window.setWindowTitle("Plus minus");
  window.show();

  return app.exec();
}
```

在原版英文教程中没有给出编译方法【~即没有给出pro文件的内容】，这里可能会有一些坑要踩。我们首先来看一下源文件中有什么不太一样的地方，然后给出编译的方法。

我们来看`plusminus.h`文件。首先我们要注意到`Q_OBJECT`这个宏。这个宏放在这里是我们使用Qt提供的信号与回调（槽）【~我也是刚开始学习，这里描述措辞后续可能需要更改】的必要条件。宏的内容，实际上是定义了一些函数和属性，并且`qmake`编译系统在扫描到这个文件时，会自动生成实现这些函数的文件。另一需要注意的点是，在`OnPlus`和`OnMinus`声明的前面有`private slots`字段。这里的`slots`也是一个特殊的宏，起作用是将其后的函数标注为可供Qt事件响应系统的回调函数。

要编译这几个文件，在处理pro文件时需要注意这么几点：

1. 添加`Headers += plusminus.h`。如果没有这句话，编译系统就无法为`Q_OBJECT`标注的类创建需要的源文件，导致链接时出现`Undefined symbols for architecture XXX`类型的错误。
2. 这里编译过程的中间临时文件比较多，建议在pro文件里面添加

```make
OBJECTS_DIR=tmp
MOC_DIR=tmp
```

完整的pro文件如下：

```make
######################################################################
# Automatically generated by qmake (3.1) Wed Sep 18 17:05:09 2019
######################################################################

TEMPLATE = app
TARGET = learnQt
INCLUDEPATH += .

# You can make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# Please consult the documentation of the deprecated API in order to know
# how to port your code away from it.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

OBJECTS_DIR=tmp
MOC_DIR=tmp

# Input
SOURCES += main.cpp plusminus.cpp
HEADERS += plusminus.h

QT += widgets
```

程序运行的界面如下：

<img src="https://imgs.codewoody.com/uploads/big/d8119dbb52ad1289549bb8e29916dcba.png" style="width: 70%; border: none">

## [Menus and toobars](http://zetcode.com/gui/qt5/menusandtoolbars/)

这里来介绍菜单和工具栏的使用。尽管在不同的操作系统下他们长的不一样，但是Qt提供了一致的接口。

### 简单的例子

下面的例子给出了最简单的Menu功能演示。我们分成三个文件：

```cpp
// simplemenu.h
#pragma once

#include <QMainWindow>
#include <QApplication>

class SimpleMenu : public QMainWindow {

  public:
    SimpleMenu(QWidget *parent = 0);
};
```

```cpp
// simplemenu.cpp
#include "simplemenu.h"
#include <QMenu>
#include <QMenuBar>

SimpleMenu::SimpleMenu(QWidget *parent)
    : QMainWindow(parent) {
    
  QAction *quit = new QAction("&Quit", this);

  QMenu *file;
  file = menuBar()->addMenu("&File");
  file->addAction(quit);

  connect(quit, &QAction::triggered, qApp, QApplication::quit);
}
```

```cpp
// main.cpp
#include "simplemenu.h"

int main(int argc, char *argv[]) {

  QApplication app(argc, argv);  

  SimpleMenu window;

  window.resize(250, 150);
  window.setWindowTitle("Simple menu");
  window.show();

  return app.exec();
}
```

这个例子在Mac上运行没法看到"File"这个菜单栏选项。为什么呢？这是因为在MAC中，名称为`Quit`的Action会被自动整合到名称为应用名的首个菜单项目里面去。要看到独立的`File`菜单选项，需要把`Quit`改成其他名字就好了。

<img src="https://imgs.codewoody.com/uploads/big/4eafd4e6e49effd13e8b92370496204c.png" style="width: 70%">
<figcaption>图片出处：https://forum.qt.io/topic/98908/menubar-in-macos-not-working/9</figcaption>
<br>
Qt 的官方网文档在[这里](https://doc.qt.io/qt-5/qmenubar.html#details)说明了原因:

> Qt for macOS also provides a menu bar merging feature to make QMenuBar conform more closely to accepted macOS menu bar layout. The merging functionality is based on string matching the title of a QMenu entry. These strings are translated (using `QObject::tr()`) in the "QMenuBar" context. If an entry is moved its slots will still fire as if it was in the original place. The table below outlines the strings looked for and where the entry is placed if matched:

<img src="https://imgs.codewoody.com/uploads/big/9079590b1679702a8da8ca51be4c6573.png" style="border: none">

### Toolbar

> 这部分最近应该用不到，先不实验，把教程内容搬过来

```toolbar.h
#pragma once

#include <QMainWindow>
#include <QApplication>

class Toolbar : public QMainWindow {
    
  Q_OBJECT  

  public:
    Toolbar(QWidget *parent = 0);
};
```

```toolbar.cpp
#include "toolbar.h"
#include <QToolBar>
#include <QIcon>
#include <QAction>

Toolbar::Toolbar(QWidget *parent)
    : QMainWindow(parent) {
    
  QPixmap newpix("new.png");
  QPixmap openpix("open.png");
  QPixmap quitpix("quit.png");
  
  QToolBar *toolbar = addToolBar("main toolbar");
  toolbar->addAction(QIcon(newpix), "New File");
  toolbar->addAction(QIcon(openpix), "Open File");
  toolbar->addSeparator();
  QAction *quit = toolbar->addAction(QIcon(quitpix), 
      "Quit Application");
  
  connect(quit, &QAction::triggered, qApp, &QApplication::quit);
}
```

```cpp
// main.cpp
#include "toolbar.h"

int main(int argc, char *argv[]) {
    
  QApplication app(argc, argv);  
    
  Toolbar window;

  window.resize(300, 200);
  window.setWindowTitle("QToolBar");
  window.show();

  return app.exec();
}
```
